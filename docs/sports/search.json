[
  {
    "objectID": "bumpcharts.html",
    "href": "bumpcharts.html",
    "title": "25  Bump charts",
    "section": "",
    "text": "The point of a bump chart is to show how the ranking of something changed over time – you could do this with the top 25 in football or basketball. I’ve seen it done with European soccer league standings over a season.\nThe requirements are that you have a row of data for a team, in that week, with their rank.\nThis is another extension to ggplot, and you’ll install it the usual way: install.packages(\"ggbump\")\n\nlibrary(tidyverse)\nlibrary(ggbump)\n\nLet’s use the 2024-25 college football playoff rankings:\nFor this walkthrough:\n   Download csv file\n\n\nrankings &lt;- read_csv(\"data/cfbranking24.csv\")\n\nRows: 150 Columns: 3\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): Team\ndbl (2): Week, Rank\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nGiven our requirements of a row of data for a team, in that week, with their rank, take a look at the data provided. We have 5 weeks of playoff rankings, so we should see a ranking, the week of the ranking and the team at that rank. You can see the basic look of the data by using head()\n\nhead(rankings)\n\n# A tibble: 6 × 3\n   Week  Rank Team      \n  &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;     \n1    10     1 Oregon    \n2    10     2 Ohio State\n3    10     3 Georgia   \n4    10     4 Miami     \n5    10     5 Texas     \n6    10     6 Penn State\n\n\nSo Oregon was ranked in the first (yawn), followed by Ohio State (double yawn), Georgia (of course), Miami (!) and so on. Our data is in the form we need it to be. Now we can make a bump chart. We’ll start simple.\n\nggplot() + \n  geom_bump(\n    data=rankings, aes(x=Week, y=Rank, color=Team))\n\nWarning in compute_group(...): 'StatBump' needs at least two observations per\ngroup\nWarning in compute_group(...): 'StatBump' needs at least two observations per\ngroup\n\n\n\n\n\n\n\n\n\nWell, it’s a start.\nThe warning that you’re seeing is that there are two teams last season that made one appearance in the college football playoff rankings and disappeared. Some fans would bite your arm off for that. Alas. We should eliminate them and thin up our chart a little. Let’s just take teams that finished in the top 10. We’re going to use a neat filter trick for this that you learned earlier using %in%.\n\ntop10 &lt;- rankings |&gt; filter(Week == 15 & Rank &lt;= 10)\n\nnewrankings &lt;- rankings |&gt; filter(Team %in% top10$Team)\n\nNow you have something called newrankings that shows how teams who finished in the top 10 at the end of the season ended up there. And every team who finished in the top 10 in week 17 had been in the rankings more than once in the 5 weeks before.\n\nggplot() + \n  geom_bump(\n    data=newrankings, aes(x=Week, y=Rank, color=Team))\n\n\n\n\n\n\n\n\nFirst things first: I’m immediately annoyed by the top teams being at the bottom. I learned a neat trick from ggbump that’s been in ggplot all along – scale_y_reverse()\n\nggplot() + \n  geom_bump(\n    data=newrankings, aes(x=Week, y=Rank, color=Team)) + \n  scale_y_reverse()\n\n\n\n\n\n\n\n\nBetter. But, still not great. Let’s add a point at each week.\n\nggplot() + \n  geom_bump(data=newrankings, aes(x=Week, y=Rank, color=Team)) + \n  geom_point(data=newrankings, aes(x=Week, y=Rank, color=Team), size = 4) +\n  scale_y_reverse() \n\n\n\n\n\n\n\n\nAnother step. That makes it more subway-map like. But the colors are all wrong. To fix this, we’re going to use scale_color_manual and we’re going to Google the hex codes for each team. The legend will tell you what order your scale_color_manual needs to be.\n\nggplot() + \n  geom_bump(data=newrankings, aes(x=Week, y=Rank, color=Team)) + \n  geom_point(data=newrankings, aes(x=Week, y=Rank, color=Team), size = 4) + \n  scale_color_manual(values = c(\"HEX CODE\", \"HEX CODE\")) + # replace HEX CODE with each team's code\n  scale_y_reverse() \n\nAnother step. But the legend is annoying. And trying to find which red is Alabama vs Ohio State is hard. So what if we labeled each dot at the beginning and end? We can do that with some clever usage of geom_text and a little dplyr filtering inside the data step. We filter out the first and last weeks, then use hjust – horizontal justification – to move them left or right.\n\nggplot() + \n  geom_bump(data=newrankings, aes(x=Week, y=Rank, color=Team)) + \n  geom_point(data=newrankings, aes(x=Week, y=Rank, color=Team), size = 4) +   \n  geom_text(data = newrankings |&gt; filter(Week == min(Week)), aes(x = Week - .2, y=Rank, label = Team), size = 3, hjust = 1) +\n  geom_text(data = newrankings |&gt; filter(Week == max(Week)), aes(x = Week + .2, y=Rank, label = Team), size = 3, hjust = 0) +\n  scale_color_manual(values = c(\"HEX CODE\", \"HEX CODE\")) # replace HEX CODE with each team's code) +\n  scale_y_reverse() \n\nBetter, but the legend is still there. We can drop it in a theme directive by saying legend.position = \"none\". We’ll also throw a theme_minimal on there to drop the default grey, and we’ll add some better labeling.\n\nggplot() + \n  geom_bump(data=newrankings, aes(x=Week, y=Rank, color=Team)) + \n  geom_point(data=newrankings, aes(x=Week, y=Rank, color=Team), size = 4) +   \n  geom_text(data = newrankings |&gt; filter(Week == min(Week)), aes(x = Week - .2, y=Rank, label = Team), size = 3, hjust = 1) +\n  geom_text(data = newrankings |&gt; filter(Week == max(Week)), aes(x = Week + .2, y=Rank, label = Team), size = 3, hjust = 0) +\n  labs(title=\"The top ten was anything but boring in 2024-25\", subtitle=\"\", y= \"Rank\", x = \"Week\") +\n  theme_minimal() +\n  theme(\n    legend.position = \"none\",\n    panel.grid.major = element_blank()\n    ) +\n  scale_color_manual(values = c(\"HEX CODE\", \"HEX CODE\")) # replace HEX CODE with each team's code) +\n  scale_y_reverse() \n\nNow let’s fix our text hierarchy.\n\nggplot() + \n  geom_bump(data=newrankings, aes(x=Week, y=Rank, color=Team)) + \n  geom_point(data=newrankings, aes(x=Week, y=Rank, color=Team), size = 4) +   \n  geom_text(data = newrankings |&gt; filter(Week == min(Week)), aes(x = Week - .2, y=Rank, label = Team), size = 3, hjust = 1) +\n  geom_text(data = newrankings |&gt; filter(Week == max(Week)), aes(x = Week + .2, y=Rank, label = Team), size = 3, hjust = 0) +\n  labs(title=\"The top ten was anything but boring in 2024-25\", subtitle=\"\", y= \"Rank\", x = \"Week\") +\n  theme_minimal() +\n  theme(\n    legend.position = \"none\",\n    panel.grid.major = element_blank(),\n    plot.title = element_text(size = 16, face = \"bold\"),\n    axis.title = element_text(size = 8), \n    plot.subtitle = element_text(size=10), \n    panel.grid.minor = element_blank()\n    ) +\n  scale_color_manual(values = c(\"HEX CODE\", \"HEX CODE\")) # replace HEX CODE with each team's code) +\n  scale_y_reverse() \n\nAnd the last thing: anyone else annoyed at 7.5th place on the left? We can fix that too by specifying the breaks in scale_y_reverse. We can do that with the x axis as well, but since we haven’t reversed it, we do that in scale_x_continuous with the same breaks. Also: forgot my source and credit line.\nOne last thing: Let’s change the width of the chart to make the names fit. We can do that by adding fig.width=X in the {r} setup in your block. So something like this:\n\nggplot() + \n  geom_bump(data=newrankings, aes(x=Week, y=Rank, color=Team)) + \n  geom_point(data=newrankings, aes(x=Week, y=Rank, color=Team), size = 4) +   \n  geom_text(data = newrankings |&gt; filter(Week == min(Week)), aes(x = Week - .2, y=Rank, label = Team), size = 3, hjust = 1) +\n  geom_text(data = newrankings |&gt; filter(Week == max(Week)), aes(x = Week + .2, y=Rank, label = Team), size = 3, hjust = 0) +\n  labs(title=\"The top ten was anything but boring in 2024-25\", subtitle=\"\", y= \"Rank\", x = \"Week\") +\n  theme_minimal() +\n  theme(\n    legend.position = \"none\",\n    panel.grid.major = element_blank(),\n    plot.title = element_text(size = 16, face = \"bold\"),\n    axis.title = element_text(size = 8), \n    plot.subtitle = element_text(size=10), \n    panel.grid.minor = element_blank()\n    ) +\n  scale_color_manual(values = c(\"HEX CODE\", \"HEX CODE\")) # replace HEX CODE with each team's code) +\n  scale_x_continuous(breaks=c(13,14,15,16,17)) + \n  scale_y_reverse(breaks=c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15))",
    "crumbs": [
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Bump charts</span>"
    ]
  },
  {
    "objectID": "encirclingpoints.html",
    "href": "encirclingpoints.html",
    "title": "29  Encircling points on a scatterplot",
    "section": "",
    "text": "29.1 A different, more local example\nOne thing we’ve talked about all semester is drawing attention to the thing you want to draw attention to. We’ve used color and labels to do that so far. Let’s add another layer to it – a shape around the points you want to highlight.\nRemember: The point of all of this is to draw the eye to what you are trying to show your reader. You want people to see the story you are trying to tell.\nIt’s not hard to draw a shape in ggplot – it is a challenge to put it in the right place. But, there is a library to the rescue that makes this super easy – ggalt.\nInstall it in the console with install.packages(\"ggalt\")\nThere’s a bunch of things that ggalt does, but one of the most useful for us is the function encircle. Let’s dive in.\nLet’s say we want to highlight the top scorers in women’s college lacrosse. So let’s use our player data.\nAnd while we’re loading it, let’s filter out anyone who hasn’t played.\nWe’ve done this before, but let’s make a standard scatterplot of games and points.\nSo we can see right away that there are some dots at the very top that we’d want to highlight. Who are these scoring machines?\nLike we have done in the past, let’s make a dataframe of top scorers. We’ll set the cutoff at 120 points.\nAnd like we’ve done in the past, we can add it to the chart with another geom_point. We’ll make all the players grey, we’ll make all the top scorers black.\nAnd like that, we’re on the path to something publishable. We’ll need to label those dots with ggrepel and we’ll need to drop the default grey and add some headlines and all that. And, for the most part, we’ve got a solid chart.\nBut what if we could really draw the eye to those players. Let’s draw a circle around them. In ggalt, there is a new geom called geom_encircle, which … does what you think it does. It encircles all the dots in a dataset.\nSo let’s add geom_encircle and we’ll just copy the data and the aes from our topscorers geom_point. Then, we need to give the encirclement a shape using s_shape – which is a number between 0 and 1 – and then how far away from the dots to draw the circle using expand, which is another number between 0 and 1.\nLet’s start with s_shape 1 and expand 1.\nWhoa. That’s … not good.\nLet’s go the opposite direction.\nBetter, but … the circle cuts through multiple dots.\nThis takes a little bit of finessing, but a shape of .5 means the line will have some bend to it – it’ll look more like someone circled it with a pen. Then, the expand is better if you use hundredths instead of tenths. So .01 instead of .1. Here’s mine after fiddling with it for a bit, and I’ll add in player names as a label, use geom_text_repel to make some space for the names and extend the x-axis for more room.\nNow let’s clean this up and make it presentable. If you look at the top scorers, all four are guards. So here’s what a chart telling that story might look like.\nYou can use circling outside of the top of something. It’s a bit obvious that the previous dots were top scorers. What about when they aren’t at the top?\nWorks the same way – use layering and color smartly and tell the story with all your tools.\nLet’s grab the top three point attempt takers on the 2024-25 Maryland roster.\nplayers24 &lt;- read_csv(\"https://thescoop.org/sports-data-files/players25.csv\")\n\nRows: 5818 Columns: 57\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (10): Team, Player, Class, Height, Hometown, High School, Summary, Pos, ...\ndbl (47): #, Weight, G, GS, MP, FG, FGA, FG%, 3P, 3PA, 3P%, 2P, 2PA, 2P%, eF...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nmdtop &lt;- players24 |&gt; filter(Team == \"Maryland Terrapins Men's\") |&gt; top_n(3, `3PA`)\nAnd just like above, we can plug in our players geom, our mdtop dataframe into another geom, then encircle that dataframe. Slap some headlines and annotations on it and here’s what we get:\nggplot() + \n  geom_point(data=players24, aes(x=MP, y=`3PA`), color=\"grey\") + \n  geom_point(data=mdtop, aes(x=MP, y=`3PA`), color=\"red\") + \n  geom_encircle(data=mdtop, aes(x=MP, y=`3PA`), s_shape=.02, expand=.10, colour=\"red\") +\n  geom_text_repel(data=mdtop, aes(x=MP, y=`3PA`, label=Player)) +\n  geom_text(aes(x=400, y=200, label=\"Maryland's top three shooters\")) + \n  labs(title=\"Terp Task: Replace the Big Three\", subtitle=\"None of Maryland's most prolific long-range shooters return this season\", x=\"Minutes\", y=\"Three point attempts\") + \n  theme_minimal() + \n  theme(\n    plot.title = element_text(size = 16, face = \"bold\"),\n    axis.title = element_text(size = 8), \n    plot.subtitle = element_text(size=10), \n    panel.grid.minor = element_blank()\n    )\n\nWarning: Removed 929 rows containing missing values or values outside the scale range\n(`geom_point()`).\nNone of them return this season.",
    "crumbs": [
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Encircling points on a scatterplot</span>"
    ]
  },
  {
    "objectID": "usingpackages.html",
    "href": "usingpackages.html",
    "title": "38  Using packages to get data",
    "section": "",
    "text": "38.1 Using cfbfastR as a cautionary tale\nThere is a growing number of packages and repositories of sports data, largely because there’s a growing number of people who want to analyze that data. We’ve done it ourselves with simple Google Sheets tricks. Then there’s RVest, which is a method of scraping the data yourself from websites. But with these packages, someone has done the work of gathering the data for you. All you have to learn are the commands to get it.\nOne very promising collection of libraries is something called the SportsDataverse, which has a collection of packages covering specific sports, all of which are in various stages of development. Some are more complete than others, but they are all being actively worked on by developers. Packages of interest in this class are:\nNot part of the SportsDataverse, but in the same neighborhood, is nflfastR, which can provide NFL play-by-play data.\nBecause they’re all under development, not all of them can be installed with just a simple install.packages(\"something\"). Some require a little work, some require API keys.\nThe main issue for you is to read the documentation carefully.\ncfbfastR presents us a good view into the promise and peril of libraries like this.\nFirst, to make this work, follow the installation instructions and then follow how to get an API key from College Football Data and how to add that to your environment. But maybe wait to do that until you read the whole section.\nAfter installations, we can load it up.\nlibrary(tidyverse)\nlibrary(cfbfastR)\nYou might be thinking, “Oh wow, I can get play by play data for college football. Let’s look at what are the five most heartbreaking plays of last year’s Maryland season.” Because what better way to determine doom than by looking at the steepest drop-off in win probability, which is included in the data.\nGreat idea. Let’s do it. You’ll need to make sure that your API key has been added to your environment.\nThe first thing to do is read the documentation. You’ll see that you can request data for each week. For example, here’s week 1 against Buffalo.\nmaryland &lt;- cfbd_pbp_data(\n 2024,\n  week=1, \n  season_type = \"regular\",\n  team = \"Maryland\",\n  epa_wpa = TRUE,\n)\nThere’s not an easy way to get all of a single team’s games. A way to do it that’s not very pretty but it works is like this:\nwk1 &lt;- cfbd_pbp_data(2022, week=1, season_type = \"regular\", team = \"Maryland\", epa_wpa = TRUE)\nSys.sleep(2)\nwk2 &lt;- cfbd_pbp_data(2022, week=2, season_type = \"regular\", team = \"Maryland\", epa_wpa = TRUE)\nSys.sleep(2)\nwk3 &lt;- cfbd_pbp_data(2022, week=3, season_type = \"regular\", team = \"Maryland\", epa_wpa = TRUE)\nSys.sleep(2)\nwk4 &lt;- cfbd_pbp_data(2022, week=4, season_type = \"regular\", team = \"Maryland\", epa_wpa = TRUE)\nSys.sleep(2)\nwk5 &lt;- cfbd_pbp_data(2022, week=5, season_type = \"regular\", team = \"Maryland\", epa_wpa = TRUE)\nSys.sleep(2)\nwk6 &lt;- cfbd_pbp_data(2022, week=6, season_type = \"regular\", team = \"Maryland\", epa_wpa = TRUE)\nSys.sleep(2)\nwk8 &lt;- cfbd_pbp_data(2022, week=8, season_type = \"regular\", team = \"Maryland\", epa_wpa = TRUE)\nSys.sleep(2)\nwk9 &lt;- cfbd_pbp_data(2022, week=9, season_type = \"regular\", team = \"Maryland\", epa_wpa = TRUE)\nSys.sleep(2)\nwk10 &lt;- cfbd_pbp_data(2022, week=10, season_type = \"regular\", team = \"Maryland\", epa_wpa = TRUE)\nSys.sleep(2)\nwk11 &lt;- cfbd_pbp_data(2022, week=11, season_type = \"regular\", team = \"Maryland\", epa_wpa = TRUE)\nSys.sleep(2)\nwk12 &lt;- cfbd_pbp_data(2022, week=12, season_type = \"regular\", team = \"Maryland\", epa_wpa = TRUE)\n\numplays &lt;- bind_rows(wk1, wk2, wk3, wk4, wk5, wk6, wk8, wk9, wk10, wk11, wk12)\nThe sys.sleep bits just pauses for two seconds before running the next block. Since we’re requesting data from someone else’s computer, we want to be kind. Week 2 was a bye week for Maryland, so if you request it, you’ll get an empty request and a warning. The bind_rows parts puts all the dataframes into a single dataframe.\nNow you’re ready to look at heartbreak. How do we define heartbreak? How about like this: you first have to lose the game, it comes in the third or fourth quarter, it involves a play (i.e. not a timeout), and it results in the biggest drop in win probability.\numplays |&gt; \n  filter(pos_team == \"Maryland\" & wk &gt; 4 & play_type != \"Timeout\") |&gt; \n  filter(period == 3 | period == 4) |&gt; \n  mutate(HeartbreakLevel = wp_before - wp_after) |&gt; \n  arrange(desc(HeartbreakLevel)) |&gt; \n  top_n(5, wt=HeartbreakLevel) |&gt;\n  select(period, clock.minutes, def_pos_team, play_type, play_text)\nThe most heartbreaking play of the season, according to our data? A third quarter run for two yards against Northwestern. Hmm - Maryland won that game, though. The other top plays - mostly against Purdue and a blocked punt by Ohio State - seem more in line with what we want.",
    "crumbs": [
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Using packages to get data</span>"
    ]
  },
  {
    "objectID": "usingpackages.html#another-example",
    "href": "usingpackages.html#another-example",
    "title": "38  Using packages to get data",
    "section": "38.2 Another example",
    "text": "38.2 Another example\nThe wehoop package is mature enough to have a version on CRAN, so you can install it the usual way with install.packages(\"wehoop\"). Another helpful library to install is progressr with install.packages(\"progressr\")\n\nlibrary(wehoop)\n\nMany of these libraries have more than play-by-play data. For example, wehoop has box scores and player data for both the WNBA and college basketball. From personal experience, WNBA data isn’t hard to get, but women’s college basketball is a giant pain.\nSo, who is Maryland’s single season points champion over the last six seasons?\n\nprogressr::with_progress({\n  wbb_player_box &lt;- wehoop::load_wbb_player_box(2021:2025)\n})\n\nWith progressr, you’ll see a progress bar in the console, which lets you know that your command is still working, since some of these requests take minutes to complete. Player box scores is quicker – five seasons was a matter of seconds.\nIf you look at the wbb_player_box data we now have, we have each player in each game over each season – more than 300,000 records. Finding out who Maryland’s top 10 single-season scoring leaders are is a matter of grouping, summing and filtering.\n\nwbb_player_box |&gt; \n  filter(team_short_display_name == \"Maryland\", !is.na(points)) |&gt; \n  group_by(athlete_display_name, season) |&gt; \n  summarise(totalPoints = sum(as.numeric(points))) |&gt; \n  arrange(desc(totalPoints)) |&gt;\n  ungroup() |&gt;\n  top_n(10, wt=totalPoints)\n\nMaryland relied on Diamond Miller’s scoring last year more than they have any player’s in the past six seasons.",
    "crumbs": [
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Using packages to get data</span>"
    ]
  }
]